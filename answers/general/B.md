# General Questions: B

> _What are the bottlenecks in terms of performance when operating on a network like Ethereum? What kind of solutions can be utilized to overcome them?_

In comparison to their centralized counterparts, decentralized networks offer greater security and fault-resistance due to their consensus-based nature. However, scalability is usually affected negatively as a trade-off for these properties. This is famously known as the _Scalability Trilemma_, popularized by Vitalik Buterin. Since the network allows anyone to participate as a non-central authority, and needs to be virtually immutable and resistant to attacks, handling a great number of transactions in a speedy manner while participation is widespread _by design_ (instead of centralized) can be a problem in terms of performance bottlenecks.

This is a widely studied problem and multiple types of solutions have been proposed. These do not exclude each other and can be combined for better results.

In terms of what can be done on-chain, the usual proposed solution is called _sharding_. Sharding means creating new, smaller chains, each housing their own transactions, therefore removing the requirement for participants to validate _all_ transactions that occur in the network. However, shards should have access to snapshots of other shards so a global view of the chain can also be built. The plan for Ethereum is to initlally use sharding to store and access data, but not execute code.

Sharding is a good alternative to the instinctively thought-of solution of increasing the block size. Increasing the block size would mean allowing for more transactions to be processed when a single block is mined, leading to a theoretically bigger throughput. However, this can be undesirable since it makes Ethereum more exclusive to actors with better, more powerful and therefore more expensive computers. This is a problem that does not occur with sharding.

In addition to this, there are proposed off-chain solutions. Some of these are known as _Layer 2_ solutions, since they work on top of the existing Ethereum blockchain and do not affect it at the protocol level, although they depend on it. They generally have components which are run by third parties or groups and receive transactions, instead of having them submitted directly to the blockchain. They usually batch these transactions and eventually post them to the chain, at which point they are as permanent as any other transaction directly submitted to the network.

Rollups are good examples of this. These execute transactions in batches and outside of mainnet, but eventually post transaction data to it. There are different types of roll-ups. "Optimistic" rollups assume off chain transactions are valid, but allow for a time window for challenges to the validity of these transactions to be submitted. This works based on a fraud-proving scheme which can detect cases of error or malicious intent. Actors proven to have submitted incorrect transaction results are penalized, and results are corrected. "Zero-knowledge" rollups also work in batches, but they are different in the sense that they provide validity proofs to prove that the changes that they are submitting are correct, using cryptography.

Additionally, a concept known as _channels_ (also layer 2) can be used in order to similarly enable participants to either make payments or update state off-chain, but periodically writing back changes to layer 1 once they are finalized. Cryptography is also used to validate results. These usually require transactions for opening and closing the channels, leaving actions in the middle to be performed off-chain between participants.

# General Questions: F

> _What process (step by step) do you follow to build a protocol (a set of smart contracts) from given specifications?_

Although it is unrealistic to pretend to fully grasp the given specifications before a single line of code is written, one should first attempt to understand it as much as possible. This is true for any development in IT, not just for writing a Solidity protocol. Efforts should be made to come up with happy flows, error scenarios and ways of handling them, edge cases, and so-on. Regardless, no matter how well understood the specifications are from the get-go, as time passes and development advances, more details shall surely come up and be made clear.

With this in mind, documentation is the logical next-step, although it too is a process that should be maintained alongside development. Having clearly documented—at least—the most relevant aspects of the protocol will be key not just for programming it, but especially for testing it. A good type of document for protocls are flow diagrams: they clearly lay out what the logical steps are for the key actions of the system. Afterwards, all documentation can eventually be made public or adapted for this purpose if the protocol is to be open source.

After the protocol is understood and reasonably documented, existing solutions should be looked into. Many blockchain projects start as forks of others, and it is not a stretch to think that this problem—or a similar one—might have already been solved by a third party already. This doesn't just save time, but it can inspire implementation aspects and provide robustness. A previously unseen problem or dimension of the issue might suddenly be discernible. Since the deployment of contracts costs funds, and protocols typically hold funds as well, hidden vulnerabilities can have a critical impact on the project as a whole.

If the protocol—adapted or not—is still deemed fit for being developed after research on existing solutions is completed, then coding of the contracts can begin. Although there is no one-size-fits-all solution, a Hardhat project in typescript is usually a good starting point. Hardhat is taking over Truffle (in terms of adoption and tool power) as a Solidity development framework, and using typescript instead of javascript allows for type generation based on contracts. The latter can be particularly useful for finding (and fixing) dApp problems when introducing changes in contracts used by another system.

For the development of the contracts themselves, tests are mandatory. If test driven development can be applied, all the better, but it is not strictly necessary. However, contracts should not be considered "done" until tests are written as well. Although tests written in Solidity are nice to have, the project will typically greatly benefit from having javascript (or typescript) tests that explicitly invoke the exposed contract functions, so these can be considered integration tests in a way. End-user tests should naturally come into play at later stages of development.

Test coverage isn't a guarantee of correctness, but it certainly helps to find bugs or problems. There are tools to measure coverage in statement and branching that come out of the box with Hardhat. 80% of coverage can usually be considered decent, but any number above that is welcome, although it provides no hard guarantees.

When writing the contracts themselves, it's a good idea to keep in mind the following points, as they frequently come up.

There are a lot of proven solutions for parts of many protocols, which are already available freely through OpenZeppelin contracts. One of these are proxies. Proxies shouldn't be included for the sake of it, but if the protocol cannot withstand the migration of its data to a newer implementation, then proxies should be adopted from the early stages. Using the plugins from OZ is currently a relatively easy and safe way to do this.

Another issue which is more easily solved through OZ tools is access control. It should be studied whether 1 or more entities should have `admin` (or other roles) for certain actions. Again, this shouldn't be taken lightly or added just for the sake of it. Badly managed access control is arguably worse than none at all, since badly managed admin-like roles could in some cases take down the entire system through exploits or abuse of privileges. On the other hand, having no admin roles could result in having the contract in a bricked state, losing funds due to bugs, or having errors permanently affecting the protocol; all of which could occur even with a proxy set up. Having access control does not detemrinistically prevent this, though, so this subject should be studied with care.

There are other Solidity patterns which are still around for historical reasons. One of them is "Checks, Effects, Interactions", which in summary means updating contract state _before_ making external calls in order to avoid possible re-entrancy errors, which have famously been catastrophic in the past. This is another good pattern to keep in mind when writing Solidity code.

Static code analysis tools like _Slither_ can help find vulnerabilities in the contracts, once written. An external audit of the smart contract code is also a sensible idea; as previously mentioned, errors in the contract side of the project can have enormous influence over the success of the project.

Gas usage should also be considered. If the protocol is too expensive to use, it will most likely fail to be adopted. There are gas profiling tools available for this purpose, particularly for Hardhat projects.

The code should be developed using regtest and first tested on such networks. Once tests have satisfactory results, they should be repeated on testnet networks, after the protocol contracts are deploy there. At the point that the protocol is validated on testnet, the project is ready to be deployed on mainnet.

Verifying the code on Etherscan (or equivalent) can be crucial for adoption if the project is open source. Without this, it can be hard for users to trust deployed contracts, since the code is not immediately available. With this in mind, writing down the Solidity compiler version as well as the optimizer parameters at the moment of deployment is a required in order to correctly verify the code.
